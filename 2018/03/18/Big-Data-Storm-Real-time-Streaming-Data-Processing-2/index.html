<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>Storm编程 | Thpffcj的树洞</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Hexo">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close">
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Thpffcj</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

</div>
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2018-03-18T10:07:47.000Z" itemprop="datePublished">
          2018-03-18
      </time>
    
    
    | 
    <a href="/tags/大数据/">大数据</a>
    
    
</span>
                <h1>Storm编程</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<ul>
<li>下面是这段时间系统了解Storm的一些记录<ul>
<li><a href="http://www.thpffcj.com/2018/03/05/Big-Data-Storm-Real-time-Streaming-Data-Processing-1/" target="_blank" rel="noopener">初识实时流处理Storm</a></li>
<li><a href="http://www.thpffcj.com/2018/03/18/Big-Data-Storm-Real-time-Streaming-Data-Processing-2/" target="_blank" rel="noopener">Storm编程</a></li>
<li><a href="http://www.thpffcj.com/2018/03/21/Big-Data-Storm-Real-time-Streaming-Data-Processing-3/" target="_blank" rel="noopener">Storm周边框架使用</a></li>
<li><a href="http://www.thpffcj.com/2018/03/29/Big-Data-Storm-Real-time-Streaming-Data-Processing-4/" target="_blank" rel="noopener">Storm架构及部署</a></li>
<li><a href="http://www.thpffcj.com/2018/03/31/Big-Data-Storm-Real-time-Streaming-Data-Processing-5/" target="_blank" rel="noopener">并行度</a></li>
<li><a href="http://www.thpffcj.com/2018/04/02/Big-Data-Storm-Real-time-Streaming-Data-Processing-6/" target="_blank" rel="noopener">分组策略与可靠性</a></li>
<li><a href="http://www.thpffcj.com/2018/04/06/Big-Data-Storm-Real-time-Streaming-Data-Processing-7/" target="_blank" rel="noopener">DRPC</a></li>
<li><a href="http://www.thpffcj.com/2018/04/07/Big-Data-Storm-Real-time-Streaming-Data-Processing-8/" target="_blank" rel="noopener">Storm整合其他大数据框架的使用</a></li>
<li><a href="http://www.thpffcj.com/2018/04/09/Big-Data-Storm-Real-time-Streaming-Data-Processing-9/" target="_blank" rel="noopener">Storm综合项目实战</a></li>
</ul>
</li>
</ul>
<p>在了解了Storm是什么后，我们就来实际感受一下Storm编程。这篇博客主要学习核心接口的使用方法，之后通过两个简单的编程案例对Storm流处理加深了解。</p>
<hr>
<h2 id="1-Storm编程"><a href="#1-Storm编程" class="headerlink" title="1. Storm编程"></a>1. Storm编程</h2><h3 id="1-基于IDEA-amp-Maven构建Storm项目"><a href="#1-基于IDEA-amp-Maven构建Storm项目" class="headerlink" title="1. 基于IDEA &amp; Maven构建Storm项目"></a>1. 基于IDEA &amp; Maven构建Storm项目</h3><ul>
<li>搭建开发环境<ul>
<li>jdk</li>
<li>IDEA</li>
<li>Maven</li>
<li>添加Maven的Storm的依赖</li>
</ul>
</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;cn.edu.nju&lt;/groupId&gt;
    &lt;artifactId&gt;151250052&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;storm&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;storm.version&gt;1.1.1&lt;/storm.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.storm&lt;/groupId&gt;
            &lt;artifactId&gt;storm-core&lt;/artifactId&gt;
            &lt;version&gt;${storm.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre><h3 id="2-ISpout核心接口"><a href="#2-ISpout核心接口" class="headerlink" title="2. ISpout核心接口"></a>2. ISpout核心接口</h3><p><strong>概述</strong></p>
<pre><code>/**
 * ISpout is the core interface for implementing spouts. A Spout is responsible
 * for feeding messages into the topology for processing. For every tuple emitted by
 * a spout, Storm will track the (potentially very large) DAG of tuples generated
 * based on a tuple emitted by the spout. When Storm detects that every tuple in
 * that DAG has been successfully processed, it will send an ack message to the Spout.
 *
 * If a tuple fails to be fully processed within the configured timeout for the
 * topology (see {@link org.apache.storm.Config}), Storm will send a fail message to the spout
 * for the message.
 *
 * When a Spout emits a tuple, it can tag the tuple with a message id. The message id
 * can be any type. When Storm acks or fails a message, it will pass back to the
 * spout the same message id to identify which tuple it&apos;s referring to. If the spout leaves out
 * the message id, or sets it to null, then Storm will not track the message and the spout
 * will not receive any ack or fail callbacks for the message.
 *
 * Storm executes ack, fail, and nextTuple all on the same thread. This means that an implementor
 * of an ISpout does not need to worry about concurrency issues between those methods. However, it 
 * also means that an implementor must ensure that nextTuple is non-blocking: otherwise 
 * the method could block acks and fails that are pending to be processed.
 */
public interface ISpout extends Serializable {

}
</code></pre><ul>
<li>ISpout<ul>
<li>核心接口(interface)，负责将数据发送到topology中去处理</li>
<li>Storm会跟踪Spout发出去的tuple的DAG</li>
<li>ack/fail</li>
<li>tuple：message id</li>
<li>ack/fail/nextTuple是在同一个线程中执行的，所以不用考虑线程安全方面</li>
</ul>
</li>
</ul>
<p><strong>核心方法</strong></p>
<pre><code>void open(Map conf, TopologyContext context, SpoutOutputCollector collector);

void close();

void activate();

void deactivate();

/**
 * When this method is called, Storm is requesting that the Spout emit tuples to the 
 * output collector. This method should be non-blocking, so if the Spout has no tuples
 * to emit, this method should return. nextTuple, ack, and fail are all called in a tight
 * loop in a single thread in the spout task. When there are no tuples to emit, it is courteous
 * to have nextTuple sleep for a short amount of time (like a single millisecond)
 * so as not to waste too much CPU.
 */
void nextTuple();

/**
 * Storm has determined that the tuple emitted by this spout with the msgId identifier
 * has been fully processed. Typically, an implementation of this method will take that
 * message off the queue and prevent it from being replayed.
 */
void ack(Object msgId);

/**
 * The tuple emitted by this spout with the msgId identifier has failed to be
 * fully processed. Typically, an implementation of this method will put that
 * message back on the queue to be replayed at a later time.
 */
void fail(Object msgId);
</code></pre><ul>
<li>open：初始化操作</li>
<li>close：资源释放操作</li>
<li>nextTuple：发送数据</li>
<li>ack：tuple处理成功，storm会反馈给spout一个成功消息</li>
<li>fail：tuple处理失败，storm会发送一个消息给spout，处理失败</li>
</ul>
<p><strong>实现类</strong></p>
<ul>
<li>public abstract class BaseRichSpout extends BaseComponent implements IRichSpout</li>
<li>public interface IRichSpout extends ISpout, IComponent</li>
<li>public class DRPCSpout extends BaseRichSpout</li>
<li>public class ShellSpout implements ISpout</li>
</ul>
<h3 id="3-IComponent核心接口"><a href="#3-IComponent核心接口" class="headerlink" title="3. IComponent核心接口"></a>3. IComponent核心接口</h3><p><strong>概述</strong></p>
<pre><code>/**
 * Common methods for all possible components in a topology. This interface is used
 * when defining topologies using the Java API. 
 */
public interface IComponent extends Serializable {

}
</code></pre><ul>
<li>为topology中所有可能的组件提供公用的方法</li>
</ul>
<p><strong>核心方法</strong></p>
<pre><code>/**
 * Declare the output schema for all the streams of this topology.
 *
 * @param declarer this is used to declare output stream ids, output fields, and whether or not each output stream is a direct stream
 */
void declareOutputFields(OutputFieldsDeclarer declarer);
</code></pre><ul>
<li>用于声明当前Spout/Bolt发送的tuple的名称</li>
<li>结合OutputFieldsDeclarer使用</li>
</ul>
<p><strong>实现类</strong></p>
<ul>
<li>public abstract class BaseRichSpout extends BaseComponent implements IRichSpout</li>
<li>public abstract class BaseComponent implements IComponent</li>
</ul>
<h3 id="IBolt核心接口"><a href="#IBolt核心接口" class="headerlink" title="IBolt核心接口"></a>IBolt核心接口</h3><p><strong>概述</strong></p>
<pre><code>/**
 * An IBolt represents a component that takes tuples as input and produces tuples
 * as output. An IBolt can do everything from filtering to joining to functions
 * to aggregations. It does not have to process a tuple immediately and may
 * hold onto tuples to process later.
 *
 * A bolt&apos;s lifecycle is as follows:
 *
 * IBolt object created on client machine. The IBolt is serialized into the topology
 * (using Java serialization) and submitted to the master machine of the cluster (Nimbus).
 * Nimbus then launches workers which deserialize the object, call prepare on it, and then
 * start processing tuples.
 *
 * If you want to parameterize an IBolt, you should set the parameters through its
 * constructor and save the parameterization state as instance variables (which will
 * then get serialized and shipped to every task executing this bolt across the cluster).
 *
 * When defining bolts in Java, you should use the IRichBolt interface which adds
 * necessary methods for using the Java TopologyBuilder API.
 */
public interface IBolt extends Serializable {

}
</code></pre><ul>
<li>职责：接收tuple数据，并进行相应的处理(filtering/joining/..)</li>
<li>hold住tuple再处理</li>
<li>IBolt会在一个运行的机器上创建，使用Java序列化它，然后提交到主节点(nimbus)上去执行，nimbus会启动worker来反序列化，调用prepare方法，然后才开始进行tuple处理</li>
</ul>
<p><strong>核心方法</strong></p>
<pre><code>/**
 * Called when a task for this component is initialized within a worker on the cluster.
 * It provides the bolt with the environment in which the bolt executes.
 *
 * This includes the:
 * 
 * @param stormConf The Storm configuration for this bolt. This is the configuration provided to the topology merged in with cluster configuration on this machine.
 * @param context This object can be used to get information about this task&apos;s place within the topology, including the task id and component id of this task, input and output information, etc.
 * @param collector The collector is used to emit tuples from this bolt. Tuples can be emitted at any time, including the prepare and cleanup methods. The collector is thread-safe and should be saved as an instance variable of this bolt object.
 */
void prepare(Map stormConf, TopologyContext context, OutputCollector collector);

/**
 * Process a single tuple of input. The Tuple object contains metadata on it
 * about which component/stream/task it came from. The values of the Tuple can
 * be accessed using Tuple#getValue. The IBolt does not have to process the Tuple
 * immediately. It is perfectly fine to hang onto a tuple and process it later
 * (for instance, to do an aggregation or join).
 *
 * Tuples should be emitted using the OutputCollector provided through the prepare method.
 * It is required that all input tuples are acked or failed at some point using the OutputCollector.
 * Otherwise, Storm will be unable to determine when tuples coming off the spouts
 * have been completed.
 *
 * For the common case of acking an input tuple at the end of the execute method,
 * see IBasicBolt which automates this.
 * 
 * @param input The input tuple to be processed.
 */
void execute(Tuple input);

/**
 * Called when an IBolt is going to be shutdown. There is no guarentee that cleanup
 * will be called, because the supervisor kill -9&apos;s worker processes on the cluster.
 *
 * The one context where cleanup is guaranteed to be called is when a topology
 * is killed when running Storm in local mode.
 */
void cleanup();
</code></pre><ul>
<li>prepare：初始化</li>
<li>execute：处理一个tuple数据，tuple对象中包含了元数据信息</li>
<li>cleanup：shutdown之前的资源清理操作</li>
</ul>
<p><strong>实现类</strong></p>
<ul>
<li>public abstract class BaseRichBolt extends BaseComponent implements IRichBolt</li>
<li>public interface IRichBolt extends IBolt, IComponent</li>
</ul>
<p><br></p>
<hr>
<h2 id="2-Storm编程实战"><a href="#2-Storm编程实战" class="headerlink" title="2. Storm编程实战"></a>2. Storm编程实战</h2><h3 id="1-求和案例编程"><a href="#1-求和案例编程" class="headerlink" title="1. 求和案例编程"></a>1. 求和案例编程</h3><p><strong>需求</strong></p>
<ul>
<li>求和案例<ul>
<li>1 + 2 + 3 + … = ???</li>
</ul>
</li>
</ul>
<p><strong>实现方案</strong></p>
<ul>
<li>Spout发送数字作为input</li>
<li>使用Bolt来处理业务逻辑：求和</li>
<li>将结果输出到控制台</li>
</ul>
<p><strong>Topology实现</strong></p>
<ul>
<li>DataSourceSpout -&gt; SumBolt</li>
</ul>
<p><strong>开发代码</strong></p>
<ul>
<li>定义数据源</li>
</ul>
<pre><code>package cn.edu.nju;

import org.apache.storm.spout.SpoutOutputCollector;
import org.apache.storm.task.TopologyContext;
import org.apache.storm.topology.OutputFieldsDeclarer;
import org.apache.storm.topology.base.BaseRichSpout;
import org.apache.storm.tuple.Fields;
import org.apache.storm.tuple.Values;
import org.apache.storm.utils.Utils;

import java.util.Map;

/**
 * Created by Thpffcj on 2018/3/20.
 * 使用Storm实现累计求和的操作
 */
public class LocalSumStormTopology {

    /**
     * Spout需要继承BaseRichSpout
     * 数据源需要产生数据并发射
     */
    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        /**
         * 初始化方法，只会被调用一次
         * @param conf 配置参数
         * @param context 上下文
         * @param collector 数据发射器
         */
        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        int number = 0;

        /**
         * 会产生数据，在生产上肯定是从消息队列中获取数据
         * 这个方法是一个死循环，会一直不停的执行
         */
        public void nextTuple() {
            this.collector.emit(new Values(number++));
            System.out.println(&quot;Spout: &quot; + number);

            // 防止数据产生太快
            Utils.sleep(1000);
        }

        /**
         * 声明输出字段
         * @param declarer
         */
        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;num&quot;));
        }
    }
}
</code></pre><ul>
<li>编写Bolt</li>
</ul>
<pre><code>public class LocalSumStormTopology {

    ...

    /**
     * 数据的累积求和Bolt：接收数据并处理
     */
    public static class SumBolt extends BaseRichBolt{

        /**
         * 初始化方法，会被执行一次
         * @param stormConf
         * @param context
         * @param collector
         */
        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {

        }

        int sum = 0;

        /**
         * 其实也是一个死循环，职责：获取Spout发送过来的数据
         * @param input
         */
        public void execute(Tuple input) {
            // Bolt中获取值可以根据index获取，也可以根据上一个环节中定义的field的名称获取(建议使用该方式)
            Integer value = input.getIntegerByField(&quot;num&quot;);
            sum += value;
            System.out.println(&quot;Bolt sum: &quot; + sum);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }
}
</code></pre><ul>
<li>Topology提交功能实现及测试</li>
</ul>
<pre><code>public class LocalSumStormTopology {

    ...

    public static void main(String[] args) {

        // TopologyBuilder根据Spout和Bolt来构建出Topology
        // Storm中任何一个作业都是通过Topology的方式进行提交的
        // Topology中需要指定Spout和Bolt的执行顺序
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SumBolt&quot;, new SumBolt()).shuffleGrouping(&quot;DataSourceSpout&quot;);

        // 创建一个本地Storm集群：本地模式运行，不需要搭建Storm集群
        LocalCluster cluster = new LocalCluster();
        cluster.submitTopology(&quot;LocalSumStormTopology&quot;, new Config(),
                builder.createTopology());
    }
}
</code></pre><ul>
<li>然后我们在控制台就可以观察到输出了</li>
</ul>
<pre><code>Spout: 1
Bolt sum: 0
Spout: 2
Bolt sum: 1
Spout: 3
Bolt sum: 3
Spout: 4
Bolt sum: 6
Spout: 5
Bolt sum: 10
Spout: 6
Bolt sum: 15
Spout: 7
Bolt sum: 21
Spout: 8
Bolt sum: 28
Spout: 9
Bolt sum: 36
Spout: 10
Bolt sum: 45
</code></pre><h3 id="2-词频统计案例编程"><a href="#2-词频统计案例编程" class="headerlink" title="2. 词频统计案例编程"></a>2. 词频统计案例编程</h3><p><strong>需求</strong></p>
<ul>
<li>读取指定目录的数据，并实现单词计数功能</li>
</ul>
<p><strong>实现方案</strong></p>
<ul>
<li>Spout来读取指定目录的数据，作为后续Bolt处理的input</li>
<li>使用一个Bolt把input的数据，切割开，我们按照逗号进行分割</li>
<li>使用一个Bolt进行最终的单词的次数统计操作</li>
<li>将结果输出到控制台</li>
</ul>
<p><strong>Topology实现</strong></p>
<ul>
<li>DataSourceSpout -&gt; SplitBolt -&gt; CountBolt</li>
</ul>
<p><strong>开发代码</strong></p>
<ul>
<li>定义数据源</li>
<li>因为nextTuple是一个死循环方法，所以我们处理完文件需要将它改名</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/3/20.
 * 使用Storm完成词频统计功能
 */
public class LocalWordCountStormTopology {

    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        /**
         * 业务：
         * 1） 读取指定目录的文件夹下的数据
         * 2） 把每一行数据发射出去
         */
        public void nextTuple() {

            // 获取所有文件
            Collection&lt;File&gt; files = FileUtils.listFiles(new File(&quot;D:/wc&quot;),
                    new String[]{&quot;txt&quot;}, true);

            for(File file : files) {
                try {
                    // 获取文件中的所有内容
                    List&lt;String&gt; lines = FileUtils.readLines(file);

                    // 获取文件中的每行的内容
                    for(String line : lines) {

                        // 发射出去
                        this.collector.emit(new Values(line));
                    }

                    // TODO... 数据处理完之后，改名，否则一直重复执行
                    FileUtils.moveFile(file, new File(file.getAbsolutePath() + System.currentTimeMillis()));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;line&quot;));
        }
    }
}
</code></pre><ul>
<li>实现对数据分割的bolt</li>
</ul>
<pre><code>public class LocalWordCountStormTopology {

    ...

    /**
     * 对数据进行分割
     */
    public static class SplitBolt extends BaseRichBolt {

        private OutputCollector collector;

        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
            this.collector = collector;
        }

        /**
         * 业务逻辑：
         *   line： 对line进行分割，按照逗号
         */
        public void execute(Tuple input) {
            String line = input.getStringByField(&quot;line&quot;);
            String[] words = line.split(&quot;,&quot;);

            for(String word : words) {
                this.collector.emit(new Values(word));
            }

        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;word&quot;));
        }
    }
}
</code></pre><ul>
<li>词频汇总</li>
</ul>
<pre><code>public class LocalWordCountStormTopology {

    ...

    /**
     * 词频汇总Bolt
     */
    public static class CountBolt extends  BaseRichBolt {

        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {

        }

        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        /**
         * 业务逻辑：
         * 1 获取每个单词
         * 2 对所有单词进行汇总
         * 3 输出
         */
        public void execute(Tuple input) {
            // 1）获取每个单词
            String word = input.getStringByField(&quot;word&quot;);
            Integer count = map.get(word);
            if(count == null) {
                count = 0;
            }

            count ++;

            // 2）对所有单词进行汇总
            map.put(word, count);

            // 3）输出
            System.out.println(&quot;-----------------------&quot;);
            Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();
            for(Map.Entry&lt;String,Integer&gt; entry : entrySet) {
                System.out.println(entry);
            }

        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }
}
</code></pre><ul>
<li>Topology提交功能实现及测试</li>
</ul>
<pre><code>public class LocalWordCountStormTopology {

    ...

    public static void main(String[] args) {

        // 通过TopologyBuilder根据Spout和Bolt构建Topology
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SplitBolt&quot;, new SplitBolt()).shuffleGrouping(&quot;DataSourceSpout&quot;);
        builder.setBolt(&quot;CountBolt&quot;, new CountBolt()).shuffleGrouping(&quot;SplitBolt&quot;);

        // 创建本地集群
        LocalCluster cluster = new LocalCluster();
        cluster.submitTopology(&quot;LocalWordCountStormTopology&quot;, new Config(), builder.createTopology());
    }
}
</code></pre><ul>
<li>查看结果</li>
</ul>
<pre><code>-----------------------
a=1
-----------------------
a=1
b=1
-----------------------
a=1
b=1
c=1
-----------------------
a=1
b=1
c=1
d=1
-----------------------
a=2
b=1
c=1
d=1
-----------------------
a=2
b=2
c=1
d=1
11144 [Thread-24-__system-executor[-1 -1]] INFO  o.a.s.d.executor - Preparing bolt __system:(-1)
-----------------------
a=2
b=2
c=2
d=1
-----------------------
a=2
b=2
c=2
d=2
11152 [Thread-24-__system-executor[-1 -1]] INFO  o.a.s.d.executor - Prepared bolt __system:(-1)
11152 [Thread-26-__acker-executor[4 4]] INFO  o.a.s.d.executor - Preparing bolt __acker:(4)
-----------------------
a=2
b=3
c=2
d=2
11154 [Thread-26-__acker-executor[4 4]] INFO  o.a.s.d.executor - Prepared bolt __acker:(4)
</code></pre><h3 id="3-编程注意事项"><a href="#3-编程注意事项" class="headerlink" title="3. 编程注意事项"></a>3. 编程注意事项</h3><ul>
<li>Spout及Bolt命名</li>
<li>Topology名称</li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2018/03/21/Big-Data-Storm-Real-time-Streaming-Data-Processing-3/" style="float: left;">
        ← Storm周边框架使用
    </a>
    
    
    <a class="pull-right" href="/2018/03/18/Java-Interview/">
        Java 面试常考考点 →
    </a>
    
</nav>

        <div class="duoshuo">


</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
				<span id="busuanzi_container_site_pv">
					本站总访问量<span id="busuanzi_value_site_pv"></span>次
				</span>	
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Thpffcj.
                </p>
                <p>私は再び1日満たすためにあなたとの重要な人々を望みます</p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- ============================ END Footer =========================== -->

      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      (function(){
        console.log('font');
        var getCss = function(path) {
          var head = document.getElementsByTagName('head')[0];
          link = document.createElement('link');
          link.href = path;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          head.appendChild(link);
        };
        getCss('https://fonts.googleapis.com/css?family=Montserrat:400,700');
        getCss('https://fonts.googleapis.com/css?family=Open+Sans:400,600');
      })();
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
