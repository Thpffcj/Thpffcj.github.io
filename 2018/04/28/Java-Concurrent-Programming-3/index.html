<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>J.U.C | Thpffcj的树洞</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Hexo">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close">
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Thpffcj</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

</div>
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2018-04-28T12:41:58.000Z" itemprop="datePublished">
          2018-04-28
      </time>
    
</span>
                <h1>J.U.C</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="1-J-U-C之AQS"><a href="#1-J-U-C之AQS" class="headerlink" title="1. J.U.C之AQS"></a>1. J.U.C之AQS</h2><h3 id="1-AQS介绍"><a href="#1-AQS介绍" class="headerlink" title="1. AQS介绍"></a>1. AQS介绍</h3><p><img src="http://oseihavwm.bkt.clouddn.com/AQS.jpg" alt=""></p>
<ul>
<li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架</li>
<li>利用了一个int类型表示状态</li>
<li>使用方法是继承</li>
<li>子类通过继承并通过实现它的方法管理其状态(acquire 和 release)的方法操纵状态</li>
<li>可以同时实现排它锁和共享锁模式(独占，共享)</li>
</ul>
<p><strong>同步组件</strong></p>
<ul>
<li>CountDownLatch</li>
<li>Semaphore</li>
<li>CyclicBarrier</li>
<li>ReentrantLock</li>
<li>Condition</li>
<li>FutureTask</li>
</ul>
<h3 id="2-CountDownLatch"><a href="#2-CountDownLatch" class="headerlink" title="2. CountDownLatch"></a>2. CountDownLatch</h3><pre><code>/**
 * Created by Thpffcj on 2018/4/27.
 */
@Slf4j
public class CountDownLatchExample1 {

    private final static int threadCount = 200;

    public static void main(String[] args) throws Exception {

        ExecutorService exec = Executors.newCachedThreadPool();

        final CountDownLatch countDownLatch = new CountDownLatch(threadCount);

        for (int i = 0; i &lt; threadCount; i++) {
            final int threadNum = i;
            exec.execute(() -&gt; {
                try {
                    test(threadNum);
                } catch (Exception e) {
                    log.error(&quot;exception&quot;, e);
                } finally {
                    countDownLatch.countDown();
                }
            });
        }
        countDownLatch.await();
        log.info(&quot;finish&quot;);
        exec.shutdown();
    }

    private static void test(int threadNum) throws Exception {
        Thread.sleep(100);
        log.info(&quot;{}&quot;, threadNum);
        Thread.sleep(100);
    }
}
</code></pre><ul>
<li>运行main方法我们可以看到在所有线程执行完之后才会输出finish，就说明了await可以保证之前的线程全部执行完</li>
</ul>
<pre><code>06:55:25.750 [pool-1-thread-182] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - 181
06:55:25.750 [pool-1-thread-181] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - 180
06:55:25.750 [pool-1-thread-175] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - 174
06:55:25.751 [pool-1-thread-180] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - 179
06:55:25.758 [pool-1-thread-188] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - 187
06:55:25.859 [main] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample1 - finish
</code></pre><ul>
<li>接下来我们看一个复杂的方法，我们启动了很多线程完成一个任务，但是这个任务我只想给它指定的时间，超过这个时间我们就不管了</li>
</ul>
<pre><code>countDownLatch.await(10, TimeUnit.MILLISECONDS);
</code></pre><ul>
<li>这就代表我们只等待10毫秒，我们看到结果先打印了finish</li>
</ul>
<pre><code>07:01:40.188 [main] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample2 - finish
07:01:40.276 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample2 - 3
07:01:40.276 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.CountDownLatchExample2 - 1
</code></pre><h3 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h3><ul>
<li>常用于仅能提供有限资源的场景</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/4/27.
 */
@Slf4j
public class SemaphoreExample1 {

    private final static int threadCount = 20;

    public static void main(String[] args) throws Exception {

        ExecutorService exec = Executors.newCachedThreadPool();

        final Semaphore semaphore = new Semaphore(3);

        for (int i = 0; i &lt; threadCount; i++) {
            final int threadNum = i;
            exec.execute(() -&gt; {
                try {
                    semaphore.acquire(); // 获取一个许可
                    test(threadNum);
                    semaphore.release(); // 释放一个许可
                } catch (Exception e) {
                    log.error(&quot;exception&quot;, e);
                }
            });
        }
        exec.shutdown();
    }

    private static void test(int threadNum) throws Exception {
        log.info(&quot;{}&quot;, threadNum);
        Thread.sleep(1000);
    }
}
</code></pre><ul>
<li>我们可以看到每一秒只能允许三个线程执行</li>
<li>实际中有时我们不光想获取一个许可，需要获取多个许可才可以执行</li>
</ul>
<pre><code>semaphore.acquire(3); // 获取多个许可
test(threadNum);
semaphore.release(3); // 释放多个许可
</code></pre><ul>
<li>可以看到当我们并发数是3，一次又需要获得三个许可，就只能执行一个调用了，就和我们单线程很像了</li>
<li>当有时并发太高了，我们想丢弃没有获得许可的请求怎么办</li>
</ul>
<pre><code>if (semaphore.tryAcquire()) { // 尝试获取一个许可
    test(threadNum);
    semaphore.release(); // 释放一个许可
}
</code></pre><ul>
<li>我们可以看到输出如下</li>
</ul>
<pre><code>07:15:19.477 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.SemaphoreExample3 - 1
07:15:19.477 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.SemaphoreExample3 - 0
07:15:19.477 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.SemaphoreExample3 - 2

Process finished with exit code 0
</code></pre><ul>
<li>因为我们的方法内有睡眠1秒，所以除了三个请求得到了执行其他请求全部被抛弃了</li>
<li>在尝试获取许可时我们可以设置等待时间</li>
</ul>
<pre><code>if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) { // 尝试获取一个许可
    test(threadNum);
    semaphore.release(); // 释放一个许可
}
</code></pre><h3 id="4-CyclicBarrier"><a href="#4-CyclicBarrier" class="headerlink" title="4. CyclicBarrier"></a>4. CyclicBarrier</h3><pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
public class CyclicBarrierExample1 {

    private static CyclicBarrier barrier = new CyclicBarrier(5);

    public static void main(String[] args) throws Exception {

        ExecutorService executor = Executors.newCachedThreadPool();

        for (int i = 0; i &lt; 10; i++) {
            final int threadNum = i;
            Thread.sleep(1000);
            executor.execute(() -&gt; {
                try {
                    race(threadNum);
                } catch (Exception e) {
                    log.error(&quot;exception&quot;, e);
                }
            });
        }
        executor.shutdown();
    }

    private static void race(int threadNum) throws Exception {
        Thread.sleep(1000);
        log.info(&quot;{} is ready&quot;, threadNum);
        barrier.await();
        log.info(&quot;{} continue&quot;, threadNum);
    }
}
</code></pre><ul>
<li>我们可以看到每隔5个线程我们就可以输出一次continue</li>
</ul>
<pre><code>7:50:22.690 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 0 is ready
07:50:23.711 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 1 is ready
07:50:24.706 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 2 is ready
07:50:25.706 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 3 is ready
07:50:26.708 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 4 is ready
07:50:26.709 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 4 continue
07:50:26.709 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 0 continue
07:50:26.709 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 2 continue
07:50:26.709 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 1 continue
07:50:26.709 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 3 continue
07:50:27.707 [pool-1-thread-6] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 5 is ready
07:50:28.707 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 6 is ready
07:50:29.707 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 7 is ready
07:50:30.707 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 8 is ready
07:50:31.708 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 9 is ready
07:50:31.708 [pool-1-thread-6] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 5 continue
07:50:31.708 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 6 continue
07:50:31.708 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 7 continue
07:50:31.708 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 8 continue
07:50:31.708 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample1 - 9 continue
</code></pre><ul>
<li>首先构造函数有一个值，告诉我们有多少线程需要同步等待，每一个线程可以调用await说明自己OK了，当达到数目时候，await之后的方法就可以执行了</li>
<li>我们也可以设置等待时间</li>
</ul>
<pre><code>private static void race(int threadNum) throws Exception {
    Thread.sleep(1000);
    log.info(&quot;{} is ready&quot;, threadNum);
    try {
        barrier.await(2000, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
        log.warn(&quot;BarrierException&quot;, e);
    }
    log.info(&quot;{} continue&quot;, threadNum);
}
</code></pre><ul>
<li>注意捕获异常，才会不影响后续执行</li>
<li>在构造函数我们还可以指定Runnable，在到达屏障时优先执行</li>
</ul>
<pre><code>private static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; {
    log.info(&quot;callback is running&quot;);
});
</code></pre><ul>
<li>可以看一下控制台</li>
</ul>
<pre><code>07:59:28.298 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 0 is ready
07:59:29.285 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 1 is ready
07:59:30.286 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 2 is ready
07:59:31.287 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 3 is ready
07:59:32.287 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 4 is ready
07:59:32.287 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - callback is running
07:59:32.287 [pool-1-thread-5] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 4 continue
07:59:32.287 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 0 continue
07:59:32.287 [pool-1-thread-2] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 1 continue
07:59:32.288 [pool-1-thread-4] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 3 continue
07:59:32.288 [pool-1-thread-3] INFO cn.edu.nju.concurrency.example.aqs.CyclicBarrierExample3 - 2 continue
</code></pre><h3 id="5-ReentrantLock与锁"><a href="#5-ReentrantLock与锁" class="headerlink" title="5. ReentrantLock与锁"></a>5. ReentrantLock与锁</h3><p><strong>ReentrantLock(可重入锁)和synchronized区别</strong></p>
<ul>
<li>可重入性</li>
<li>锁的实现</li>
<li>性能的区别</li>
<li>功能区别</li>
</ul>
<p><strong>ReentrantLock独有的功能</strong></p>
<ul>
<li>可指定是公平锁还是非公平锁</li>
<li>提供了一个Condition类，可以分组唤醒需要唤醒的线程</li>
<li>提供了能够中断等待锁的线程的机制，lock.lockInterruptibly()</li>
</ul>
<p><strong>synchronized实现锁的例子</strong></p>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
@ThreadSafe
public class LockExample1 {

    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    public static int count = 0;

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i &lt; clientTotal ; i++) {
            executorService.execute(() -&gt; {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    log.error(&quot;exception&quot;, e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;count:{}&quot;, count);
    }

    private synchronized static void add() {
        count++;
    }
}
</code></pre><p><strong>J.U.C里的锁</strong></p>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
@ThreadSafe
public class LockExample2 {

    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    public static int count = 0;

    private final static Lock lock = new ReentrantLock();

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i &lt; clientTotal ; i++) {
            executorService.execute(() -&gt; {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    log.error(&quot;exception&quot;, e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info(&quot;count:{}&quot;, count);
    }

    private static void add() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><ul>
<li>运行结果是5000，和预期一致</li>
<li>接下来我们介绍另一个锁ReentrantReadWriteLock</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
public class LockExample3 {

    private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();

    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private final Lock readLock = lock.readLock();

    private final Lock writeLock = lock.writeLock();

    public Data get(String key) {
        readLock.lock();
        try {
            return map.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public Set&lt;String&gt; getAllKeys() {
        readLock.lock();
        try {
            return map.keySet();
        } finally {
            readLock.unlock();
        }
    }

    public Data put(String key, Data value) {
        writeLock.lock();
        try {
            return map.put(key, value);
        } finally {
            readLock.unlock();
        }
    }

    class Data {

    }
}
</code></pre><ul>
<li>读写时分别加锁，加写锁时不允许存在读锁，在读请求很多时，可能使写操作饥饿<ul>
<li>实际时使用不多</li>
</ul>
</li>
<li>接下来介绍StampedLock，它控制的锁有三种模式，分别是读，写，乐观读</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
public class LockExample4 {

    class Point {
        private double x, y;
        private final StampedLock sl = new StampedLock();

        void move(double deltaX, double deltaY) { // an exclusively locked method
            long stamp = sl.writeLock();
            try {
                x += deltaX;
                y += deltaY;
            } finally {
                sl.unlockWrite(stamp);
            }
        }

        //下面看看乐观读锁案例
        double distanceFromOrigin() { // A read-only method
            long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁
            double currentX = x, currentY = y;  //将两个字段读入本地局部变量
            if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
                stamp = sl.readLock();  //如果没有，我们再次获得一个读悲观锁
                try {
                    currentX = x; // 将两个字段读入本地局部变量
                    currentY = y; // 将两个字段读入本地局部变量
                } finally {
                    sl.unlockRead(stamp);
                }
            }
            return Math.sqrt(currentX * currentX + currentY * currentY);
        }

        //下面是悲观读锁案例
        void moveIfAtOrigin(double newX, double newY) { // upgrade
            // Could instead start with optimistic, not read mode
            long stamp = sl.readLock();
            try {
                while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合
                    long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁
                    if (ws != 0L) { //这是确认转为写锁是否成功
                        stamp = ws; //如果成功 替换票据
                        x = newX; //进行状态改变
                        y = newY;  //进行状态改变
                        break;
                    } else { //如果不能成功转换为写锁
                        sl.unlockRead(stamp);  //我们显式释放读锁
                        stamp = sl.writeLock();  //显式直接进行写锁 然后再通过循环再试
                    }
                }
            } finally {
                sl.unlock(stamp); //释放读锁或写锁
            }
        }
    }
}
</code></pre><ul>
<li>我们还是回到计数的例子</li>
</ul>
<pre><code>private final static StampedLock lock = new StampedLock();

private static void add() {
    long stamp = lock.writeLock();
    try {
        count++;
    } finally {
        lock.unlock(stamp);
    }
}
</code></pre><ul>
<li>StampedLock对吞吐量有极大的提升</li>
</ul>
<p><strong>当只有少量竞争者时，synchronized是一个很好的锁实现。竞争者不少，但是线程增长的趋势是可以预估的，这时候ReentrantLock是一个很好的锁实现。</strong></p>
<ul>
<li>我们最后看一下ReentrantLock中的condition</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
public class LockExample6 {

    public static void main(String[] args) {
        ReentrantLock reentrantLock = new ReentrantLock();
        Condition condition = reentrantLock.newCondition();

        new Thread(() -&gt; {
            try {
                reentrantLock.lock();
                log.info(&quot;wait signal&quot;); // 1
                condition.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info(&quot;get signal&quot;); // 4
            reentrantLock.unlock();
        }).start();

        new Thread(() -&gt; {
            reentrantLock.lock();
            log.info(&quot;get lock&quot;); // 2
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            condition.signalAll();
            log.info(&quot;send signal ~ &quot;); // 3
            reentrantLock.unlock();
        }).start();
    }
}
</code></pre><ul>
<li>运行得到结果</li>
</ul>
<pre><code>09:36:39.423 [Thread-0] INFO cn.edu.nju.concurrency.example.lock.LockExample6 - wait signal
09:36:39.429 [Thread-1] INFO cn.edu.nju.concurrency.example.lock.LockExample6 - get lock
09:36:42.429 [Thread-1] INFO cn.edu.nju.concurrency.example.lock.LockExample6 - send signal ~ 
09:36:42.429 [Thread-0] INFO cn.edu.nju.concurrency.example.lock.LockExample6 - get signal
</code></pre><p><br></p>
<hr>
<h2 id="2-J-U-C组件拓展"><a href="#2-J-U-C组件拓展" class="headerlink" title="2. J.U.C组件拓展"></a>2. J.U.C组件拓展</h2><h3 id="1-FutureTask"><a href="#1-FutureTask" class="headerlink" title="1. FutureTask"></a>1. FutureTask</h3><ul>
<li>Callable与Runnable接口对比</li>
<li>Future接口</li>
<li>FutureTask类</li>
</ul>
<ul>
<li>首先我们演示Future</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
public class FutureExample {

    static class MyCallable implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            log.info(&quot;do something in callable&quot;);
            Thread.sleep(5000);
            return &quot;Done&quot;;
        }
    }

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        Future&lt;String&gt; future = executorService.submit(new MyCallable());
        log.info(&quot;do something in main&quot;);
        Thread.sleep(1000);
        String result = future.get();
        log.info(&quot;result：{}&quot;, result);
    }
}
</code></pre><ul>
<li>观察执行结果</li>
</ul>
<pre><code>10:49:21.691 [main] INFO cn.edu.nju.concurrency.example.aqs.FutureExample - do something in main
10:49:21.691 [pool-1-thread-1] INFO cn.edu.nju.concurrency.example.aqs.FutureExample - do something in callable
10:49:26.760 [main] INFO cn.edu.nju.concurrency.example.aqs.FutureExample - result：Done
</code></pre><ul>
<li>接着来看FutureTask</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/5/1.
 */
@Slf4j
public class FutureTaskExample {

    public static void main(String[] args) throws Exception {
        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
            @Override
            public String call() throws Exception {
                log.info(&quot;do something in callable&quot;);
                Thread.sleep(5000);
                return &quot;Done&quot;;
            }
        });

        new Thread(futureTask).start();
        log.info(&quot;do something in main&quot;);
        Thread.sleep(1000);
        String result = futureTask.get();
        log.info(&quot;result：{}&quot;, result);
    }
}
</code></pre><ul>
<li>结果和上面是一致的</li>
</ul>
<pre><code>10:50:35.817 [main] INFO cn.edu.nju.concurrency.example.aqs.FutureTaskExample - do something in main
10:50:35.817 [Thread-0] INFO cn.edu.nju.concurrency.example.aqs.FutureTaskExample - do something in callable
10:50:40.825 [main] INFO cn.edu.nju.concurrency.example.aqs.FutureTaskExample - result：Done
</code></pre><ul>
<li>FutureTask直接启动任务就可以了，什么时候想用什么时候用</li>
</ul>
<h3 id="2-Fork-Join"><a href="#2-Fork-Join" class="headerlink" title="2. Fork/Join"></a>2. Fork/Join</h3><ul>
<li><p>Fork/Join的思想其实和MapReduce很像</p>
<p>  /**</p>
<ul>
<li><p>Created by Thpffcj on 2018/5/1.<br>*/<br>@Slf4j<br>public class ForkJoinTaskExample extends RecursiveTask<integer> {</integer></p>
<p> public static final int threshold = 2;<br> private int start;<br> private int end;</p>
<p> public ForkJoinTaskExample(int start, int end) {</p>
<pre><code>this.start = start;
this.end = end;
</code></pre><p> }</p>
<p> @Override<br> protected Integer compute() {</p>
<pre><code>int sum = 0;

//如果任务足够小就计算任务
boolean canCompute = (end - start) &lt;= threshold;
if (canCompute) {
    for (int i = start; i &lt;= end; i++) {
        sum += i;
    }
} else {
    // 如果任务大于阈值，就分裂成两个子任务计算
    int middle = (start + end) / 2;
    ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);
    ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);

    // 执行子任务
    leftTask.fork();
    rightTask.fork();

    // 等待任务执行结束合并其结果
    int leftResult = leftTask.join();
    int rightResult = rightTask.join();

    // 合并子任务
    sum = leftResult + rightResult;
}
return sum;
</code></pre><p> }</p>
<p> public static void main(String[] args) {</p>
<pre><code>ForkJoinPool forkjoinPool = new ForkJoinPool();

//生成一个计算任务，计算1+2+3+4
ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);

//执行一个任务
Future&lt;Integer&gt; result = forkjoinPool.submit(task);

try {
    log.info(&quot;result:{}&quot;, result.get());
} catch (Exception e) {
    log.error(&quot;exception&quot;, e);
}
</code></pre><p> }<br>}</p>
</li>
</ul>
</li>
<li><p>运行结果是5050</p>
</li>
</ul>
<pre><code>11:12:17.312 [main] INFO cn.edu.nju.concurrency.example.aqs.ForkJoinTaskExample - result:5050
</code></pre><h3 id="3-BlockingQueue"><a href="#3-BlockingQueue" class="headerlink" title="3. BlockingQueue"></a>3. BlockingQueue</h3><ul>
<li>阻塞队列主要用于生产者消费者模式</li>
<li>实现类<ul>
<li>ArrayBlockingQueue</li>
<li>DelayQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue </li>
</ul>
</li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2018/05/02/Java-Concurrent-Programming-4/" style="float: left;">
        ← 线程调度-线程池
    </a>
    
    
    <a class="pull-right" href="/2018/04/28/ZooKeeper-Distributed-Topics-3/">
        基于Zookeeper的应用 →
    </a>
    
</nav>

        <div class="duoshuo">


</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
				<span id="busuanzi_container_site_pv">
					本站总访问量<span id="busuanzi_value_site_pv"></span>次
				</span>	
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Thpffcj.
                </p>
                <p>私は再び1日満たすためにあなたとの重要な人々を望みます</p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- ============================ END Footer =========================== -->

      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      (function(){
        console.log('font');
        var getCss = function(path) {
          var head = document.getElementsByTagName('head')[0];
          link = document.createElement('link');
          link.href = path;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          head.appendChild(link);
        };
        getCss('https://fonts.googleapis.com/css?family=Montserrat:400,700');
        getCss('https://fonts.googleapis.com/css?family=Open+Sans:400,600');
      })();
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
