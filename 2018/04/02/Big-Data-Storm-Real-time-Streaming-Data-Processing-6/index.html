<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>分组策略与可靠性 | Thpffcj的树洞</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Hexo">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Thpffcj</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2018-04-02T10:18:42.000Z" itemprop="datePublished">
          2018-04-02
      </time>
    
    
    | 
    <a href='/tags/大数据/'>大数据</a>
    
    
</span>
                <h1>分组策略与可靠性</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<h2 id="1-分组策略概述"><a href="#1-分组策略概述" class="headerlink" title="1. 分组策略概述"></a>1. 分组策略概述</h2><p><strong>A stream grouping defines how that stream should be partitioned among the blolt’s tasks</strong></p>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>Stream groupings<ul>
<li>Part of defining a topology is specifying for each bolt which streams it should receive as input. A stream grouping defines how that stream should be partitioned among the bolt’s tasks.</li>
<li>There are eight built-in stream groupings in Storm, and you can implement a custom stream grouping by implementing the CustomStreamGrouping interface:<ul>
<li>Shuffle grouping: Tuples are randomly distributed across the bolt’s tasks in a way such that each bolt is guaranteed to get an equal number of tuples.</li>
<li>Fields grouping: The stream is partitioned by the fields specified in the grouping. For example, if the stream is grouped by the “user-id” field, tuples with the same “user-id” will always go to the same task, but tuples with different “user-id”‘s may go to different tasks.</li>
<li>All grouping: The stream is replicated across all the bolt’s tasks. Use this grouping with care.</li>
<li>这里只列出了我们下面要学习的三种分组方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<hr>
<h2 id="2-几种分组策略"><a href="#2-几种分组策略" class="headerlink" title="2. 几种分组策略"></a>2. 几种分组策略</h2><h3 id="1-Shuffle-Grouping"><a href="#1-Shuffle-Grouping" class="headerlink" title="1. Shuffle Grouping"></a>1. Shuffle Grouping</h3><p><strong>功能开发</strong></p>
<ul>
<li>和前面代码基本一致</li>
</ul>
<pre><code>public class ClusterSumShuffleGroupingStormTopology {

    /**
     * Spout需要继承BaseRichSpout
     * 数据源需要产生数据并发射
     */
    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        /**
         * 初始化方法，只会被调用一次
         *
         * @param conf      配置参数
         * @param context   上下文
         * @param collector 数据发射器
         */
        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        int number = 0;

        /**
         * 会产生数据，在生产上肯定是从消息队列中获取数据
         * &lt;p&gt;
         * 这个方法是一个死循环，会一直不停的执行
         */
        public void nextTuple() {
            this.collector.emit(new Values(++number));

            System.out.println(&quot;Spout: &quot; + number);

            // 防止数据产生太快
            Utils.sleep(1000);

        }

        /**
         * 声明输出字段
         *
         * @param declarer
         */
        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;num&quot;));
        }
    }


    /**
     * 数据的累积求和Bolt：接收数据并处理
     */
    public static class SumBolt extends BaseRichBolt {

        /**
         * 初始化方法，会被执行一次
         *
         * @param stormConf
         * @param context
         * @param collector
         */
        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {

        }

        int sum = 0;

        /**
         * 其实也是一个死循环，职责：获取Spout发送过来的数据
         *
         * @param input
         */
        public void execute(Tuple input) {

            // Bolt中获取值可以根据index获取，也可以根据上一个环节中定义的field的名称获取(建议使用该方式)
            Integer value = input.getIntegerByField(&quot;num&quot;);
            sum += value;

            System.out.println(&quot;Bolt: sum = [&quot; + sum + &quot;]&quot;);
            System.out.println(&quot;Thread id: &quot; + Thread.currentThread().getId() + &quot; receive data &quot; + value);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }

    public static void main(String[] args) {

        // TopologyBuilder根据Spout和Bolt来构建出Topology
        // Storm中任何一个作业都是通过Topology的方式进行提交的
        // Topology中需要指定Spout和Bolt的执行顺序
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SumBolt&quot;, new SumBolt(), 3).shuffleGrouping(&quot;DataSourceSpout&quot;);

        // 代码提交到Storm集群上运行
        String topoName = ClusterSumShuffleGroupingStormTopology.class.getSimpleName();
        try {
            StormSubmitter.submitTopology(topoName, new Config(), builder.createTopology());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>环境测试</strong></p>
<ul>
<li>启动storm</li>
</ul>
<pre><code>[thpffcj@thpffcj bin]$ nohup sh storm dev-zookeeper &amp;
[1] 3858
[thpffcj@thpffcj bin]$ nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;
[thpffcj@thpffcj bin]$ nohup sh storm nimbus &amp;
[2] 3920
nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;
[thpffcj@thpffcj bin]$ nohup sh storm supervisor &amp;
[3] 3999
nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;
[thpffcj@thpffcj bin]$ nohup sh storm ui &amp;
[4] 4030
nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;
[thpffcj@thpffcj bin]$ nohup sh storm logviewer &amp;
[5] 4125
nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;

[thpffcj@thpffcj bin]$ jps -l
3920 org.apache.storm.daemon.nimbus
3858 org.apache.storm.command.dev_zookeeper
4343 sun.tools.jps.Jps
4125 org.apache.storm.daemon.logviewer
4030 org.apache.storm.ui.core
3999 org.apache.storm.daemon.supervisor.Supervisor
</code></pre><ul>
<li>启动项目</li>
</ul>
<pre><code>[thpffcj@thpffcj bin]$ storm jar /home/thpffcj/lib/storm-1.0.jar cn.edu.nju.ClusterSumShuffleGroupingStormTopology
...
1718 [main] INFO  o.a.s.StormSubmitter - Finished submitting topology: ClusterSumShuffleGroupingStormTopology
</code></pre><ul>
<li>到UI界面查看信息</li>
</ul>
<p><img src="http://oseihavwm.bkt.clouddn.com/ShuffleGrouping.png" alt=""></p>
<ul>
<li>我们可以点击端口查看日志信息</li>
</ul>
<pre><code>2018-04-01 16:20:42.039 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 1
2018-04-01 16:20:42.042 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [1]
2018-04-01 16:20:42.042 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 1
2018-04-01 16:20:43.040 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 2
2018-04-01 16:20:43.048 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [3]
2018-04-01 16:20:43.048 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 2
2018-04-01 16:20:44.041 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 3
2018-04-01 16:20:44.043 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [3]
2018-04-01 16:20:44.044 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 3
2018-04-01 16:20:45.042 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 4
2018-04-01 16:20:45.047 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [7]
2018-04-01 16:20:45.047 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 4
2018-04-01 16:20:46.043 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 5
2018-04-01 16:20:46.045 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [8]
2018-04-01 16:20:46.045 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 5
2018-04-01 16:20:47.044 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 6
2018-04-01 16:20:47.052 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [14]
2018-04-01 16:20:47.052 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 6
2018-04-01 16:20:48.044 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 7
2018-04-01 16:20:48.046 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [14]
2018-04-01 16:20:48.047 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 7
2018-04-01 16:20:49.045 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 8
2018-04-01 16:20:49.048 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [22]
2018-04-01 16:20:49.048 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 8
2018-04-01 16:20:50.048 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 9
2018-04-01 16:20:50.059 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [23]
2018-04-01 16:20:50.059 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 9
2018-04-01 16:20:51.049 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 10
2018-04-01 16:20:51.054 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [33]
2018-04-01 16:20:51.054 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 10
</code></pre><ul>
<li>我们一条消息发出来，三个进程同时消费</li>
</ul>
<h3 id="2-Fields-Grouping"><a href="#2-Fields-Grouping" class="headerlink" title="2. Fields Grouping"></a>2. Fields Grouping</h3><p><strong>功能开发</strong></p>
<ul>
<li>注意修改nextTuple，declareOutputFields，main方法</li>
</ul>
<pre><code>public class ClusterSumFieldGroupingStormTopology {

    /**
     * Spout需要继承BaseRichSpout
     * 数据源需要产生数据并发射
     */
    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        /**
         * 初始化方法，只会被调用一次
         *
         * @param conf      配置参数
         * @param context   上下文
         * @param collector 数据发射器
         */
        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        int number = 0;

        /**
         * 会产生数据，在生产上肯定是从消息队列中获取数据
         * &lt;p&gt;
         * 这个方法是一个死循环，会一直不停的执行
         */
        public void nextTuple() {
            this.collector.emit(new Values(number % 2, ++number));

            System.out.println(&quot;Spout: &quot; + number);

            // 防止数据产生太快
            Utils.sleep(1000);

        }

        /**
         * 声明输出字段
         *
         * @param declarer
         */
        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;flag&quot;, &quot;num&quot;));
        }
    }


    /**
     * 数据的累积求和Bolt：接收数据并处理
     */
    public static class SumBolt extends BaseRichBolt {

        /**
         * 初始化方法，会被执行一次
         *
         * @param stormConf
         * @param context
         * @param collector
         */
        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {

        }

        int sum = 0;

        /**
         * 其实也是一个死循环，职责：获取Spout发送过来的数据
         *
         * @param input
         */
        public void execute(Tuple input) {

            // Bolt中获取值可以根据index获取，也可以根据上一个环节中定义的field的名称获取(建议使用该方式)
            Integer value = input.getIntegerByField(&quot;num&quot;);
            sum += value;

            System.out.println(&quot;Bolt: sum = [&quot; + sum + &quot;]&quot;);
            System.out.println(&quot;Thread id: &quot; + Thread.currentThread().getId() + &quot; receive data &quot; + value);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }

    public static void main(String[] args) {

        // TopologyBuilder根据Spout和Bolt来构建出Topology
        // Storm中任何一个作业都是通过Topology的方式进行提交的
        // Topology中需要指定Spout和Bolt的执行顺序
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SumBolt&quot;, new SumBolt(), 3).fieldsGrouping(&quot;DataSourceSpout&quot;, new Fields(&quot;flag&quot;));

        // 代码提交到Storm集群上运行
        String topoName = ClusterSumFieldGroupingStormTopology.class.getSimpleName();
        try {
            StormSubmitter.submitTopology(topoName, new Config(), builder.createTopology());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>环境测试</strong></p>
<ul>
<li>编译运行</li>
</ul>
<pre><code>[thpffcj@thpffcj bin]$ storm jar /home/thpffcj/lib/storm-1.0.jar cn.edu.nju.ClusterSumFieldGroupingStormTopology
...
1458 [main] INFO  o.a.s.StormSubmitter - Finished submitting topology: ClusterSumFieldGroupingStormTopology
</code></pre><ul>
<li>查看日志</li>
</ul>
<pre><code>2018-04-01 16:33:25.365 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 1
2018-04-01 16:33:25.369 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [1]
2018-04-01 16:33:25.370 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 1
2018-04-01 16:33:26.366 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 2
2018-04-01 16:33:26.374 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [2]
2018-04-01 16:33:26.374 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 2
2018-04-01 16:33:27.367 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 3
2018-04-01 16:33:27.369 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [4]
2018-04-01 16:33:27.369 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 3
2018-04-01 16:33:28.368 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 4
2018-04-01 16:33:28.371 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [6]
2018-04-01 16:33:28.372 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 4
2018-04-01 16:33:29.369 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 5
2018-04-01 16:33:29.388 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [9]
2018-04-01 16:33:29.388 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 5
2018-04-01 16:33:30.371 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 6
2018-04-01 16:33:30.378 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [12]
2018-04-01 16:33:30.378 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 6
2018-04-01 16:33:31.373 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 7
2018-04-01 16:33:31.375 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [16]
2018-04-01 16:33:31.376 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 7
2018-04-01 16:33:32.374 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 8
2018-04-01 16:33:32.377 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [20]
2018-04-01 16:33:32.377 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 8
</code></pre><ul>
<li>发现有两个线程按照奇数偶数处理数据，说明还有一个线程是多余的，说明我们的并行度设置的并不合理</li>
</ul>
<h3 id="3-All-Grouping"><a href="#3-All-Grouping" class="headerlink" title="3. All Grouping"></a>3. All Grouping</h3><p><strong>功能开发</strong></p>
<ul>
<li>其实代码基本都一致，我们主要学习测试的方法</li>
</ul>
<pre><code>public class ClusterSumAllGroupingStormTopology {

    /**
     * Spout需要继承BaseRichSpout
     * 数据源需要产生数据并发射
     */
    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        /**
         * 初始化方法，只会被调用一次
         *
         * @param conf      配置参数
         * @param context   上下文
         * @param collector 数据发射器
         */
        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        int number = 0;

        /**
         * 会产生数据，在生产上肯定是从消息队列中获取数据
         * &lt;p&gt;
         * 这个方法是一个死循环，会一直不停的执行
         */
        public void nextTuple() {
            this.collector.emit(new Values(++number));

            System.out.println(&quot;Spout: &quot; + number);

            // 防止数据产生太快
            Utils.sleep(1000);

        }

        /**
         * 声明输出字段
         *
         * @param declarer
         */
        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;num&quot;));
        }
    }


    /**
     * 数据的累积求和Bolt：接收数据并处理
     */
    public static class SumBolt extends BaseRichBolt {

        /**
         * 初始化方法，会被执行一次
         *
         * @param stormConf
         * @param context
         * @param collector
         */
        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {

        }

        int sum = 0;

        /**
         * 其实也是一个死循环，职责：获取Spout发送过来的数据
         *
         * @param input
         */
        public void execute(Tuple input) {

            // Bolt中获取值可以根据index获取，也可以根据上一个环节中定义的field的名称获取(建议使用该方式)
            Integer value = input.getIntegerByField(&quot;num&quot;);
            sum += value;

            System.out.println(&quot;Bolt: sum = [&quot; + sum + &quot;]&quot;);
            System.out.println(&quot;Thread id: &quot; + Thread.currentThread().getId() + &quot; receive data &quot; + value);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }

    public static void main(String[] args) {

        // TopologyBuilder根据Spout和Bolt来构建出Topology
        // Storm中任何一个作业都是通过Topology的方式进行提交的
        // Topology中需要指定Spout和Bolt的执行顺序
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SumBolt&quot;, new SumBolt(), 3).allGrouping(&quot;DataSourceSpout&quot;);

        // 代码提交到Storm集群上运行
        String topoName = ClusterSumAllGroupingStormTopology.class.getSimpleName();
        try {
            StormSubmitter.submitTopology(topoName, new Config(), builder.createTopology());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p><strong>环境测试</strong></p>
<pre><code>[thpffcj@thpffcj bin]$ storm jar /home/thpffcj/lib/storm-1.0.jar cn.edu.nju.ClusterSumAllGroupingStormTopology
...
1326 [main] INFO  o.a.s.StormSubmitter - Finished submitting topology: ClusterSumAllGroupingStormTopology
</code></pre><ul>
<li>查看日志</li>
</ul>
<pre><code>2018-04-01 16:41:07.386 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 1
2018-04-01 16:41:07.400 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [1]
2018-04-01 16:41:07.400 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 1
2018-04-01 16:41:07.400 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [1]
2018-04-01 16:41:07.401 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 1
2018-04-01 16:41:07.402 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Bolt: sum = [1]
2018-04-01 16:41:07.402 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Thread id: 38 receive data 1
2018-04-01 16:41:07.402 o.a.s.d.executor Thread-10-__system-executor[-1 -1] [INFO] Preparing bolt __system:(-1)
2018-04-01 16:41:07.404 o.a.s.d.executor Thread-10-__system-executor[-1 -1] [INFO] Prepared bolt __system:(-1)
2018-04-01 16:41:08.387 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 2
2018-04-01 16:41:08.389 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Bolt: sum = [3]
2018-04-01 16:41:08.390 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Thread id: 38 receive data 2
2018-04-01 16:41:08.390 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [3]
2018-04-01 16:41:08.390 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 2
2018-04-01 16:41:08.390 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [3]
2018-04-01 16:41:08.391 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 2
2018-04-01 16:41:09.388 STDIO Thread-8-DataSourceSpout-executor[1 1] [INFO] Spout: 3
2018-04-01 16:41:09.392 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Bolt: sum = [6]
2018-04-01 16:41:09.392 STDIO Thread-14-SumBolt-executor[4 4] [INFO] Thread id: 48 receive data 3
2018-04-01 16:41:09.392 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Bolt: sum = [6]
2018-04-01 16:41:09.392 STDIO Thread-6-SumBolt-executor[3 3] [INFO] Thread id: 40 receive data 3
2018-04-01 16:41:09.392 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Bolt: sum = [6]
2018-04-01 16:41:09.393 STDIO Thread-4-SumBolt-executor[2 2] [INFO] Thread id: 38 receive data 3
</code></pre><ul>
<li>可以发现每一条消息都被处理的三次</li>
</ul>
<h3 id="4-Stream-Grouping其他"><a href="#4-Stream-Grouping其他" class="headerlink" title="4. Stream Grouping其他"></a>4. Stream Grouping其他</h3><ul>
<li>Partial Key grouping: The stream is partitioned by the fields specified in the grouping, like the Fields grouping, but are load balanced between two downstream bolts, which provides better utilization of resources when the incoming data is skewed. This paper provides a good explanation of how it works and the advantages it provides.</li>
<li>Global grouping: The entire stream goes to a single one of the bolt’s tasks. Specifically, it goes to the task with the lowest id.</li>
<li>None grouping: This grouping specifies that you don’t care how the stream is grouped. Currently, none groupings are equivalent to shuffle groupings. Eventually though, Storm will push down bolts with none groupings to execute in the same thread as the bolt or spout they subscribe from (when possible).</li>
<li>Direct grouping: This is a special kind of grouping. A stream grouped this way means that the producer of the tuple decides which task of the consumer will receive this tuple. Direct groupings can only be declared on streams that have been declared as direct streams. Tuples emitted to a direct stream must be emitted using one of the <a href="javadocs/org/apache/storm/task/OutputCollector.html#emitDirect(int, int, java.util.List">emitDirect</a> methods. A bolt can get the task ids of its consumers by either using the provided TopologyContext or by keeping track of the output of the emit method in OutputCollector (which returns the task ids that the tuple was sent to).</li>
<li>Local or shuffle grouping: If the target bolt has one or more tasks in the same worker process, tuples will be shuffled to just those in-process tasks. Otherwise, this acts like a normal shuffle grouping.</li>
</ul>
<p><br></p>
<hr>
<h2 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3. 可靠性"></a>3. 可靠性</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h3><ul>
<li>Storm has several different daemon processes. Nimbus that schedules workers, supervisors that launch and kill workers, the log viewer that gives access to logs, and the UI that shows the status of a cluster.</li>
</ul>
<h3 id="2-Worker进程"><a href="#2-Worker进程" class="headerlink" title="2. Worker进程"></a>2. Worker进程</h3><ul>
<li>What happens when a worker dies?<ul>
<li>When a worker dies, the supervisor will restart it. If it continuously fails on startup and is unable to heartbeat to Nimbus, Nimbus will reschedule the worker.</li>
</ul>
</li>
</ul>
<h3 id="3-Supervisor进程和numbus进程"><a href="#3-Supervisor进程和numbus进程" class="headerlink" title="3. Supervisor进程和numbus进程"></a>3. Supervisor进程和numbus进程</h3><ul>
<li>What happens when Supervisor daemons die?<ul>
<li>The Nimbus and Supervisor daemons are designed to be fail-fast (process self-destructs whenever any unexpected situation is encountered) and stateless (all state is kept in Zookeeper or on disk). As described in Setting up a Storm cluster, the Nimbus and Supervisor daemons must be run under supervision using a tool like daemontools or monit. So if the Nimbus or Supervisor daemons die, they restart like nothing happened.</li>
<li>Most notably, no worker processes are affected by the death of Nimbus or the Supervisors. This is in contrast to Hadoop, where if the JobTracker dies, all the running jobs are lost.</li>
</ul>
</li>
</ul>
<p><strong>Is Nimbus a single point of failure?</strong></p>
<ul>
<li>If you lose the Nimbus node, the workers will still continue to function. Additionally, supervisors will continue to restart workers if they die. However, without Nimbus, workers won’t be reassigned to other machines when necessary (like if you lose a worker machine).</li>
<li>Storm Nimbus is highly available since 1.0.0.</li>
</ul>
<h3 id="4-节点"><a href="#4-节点" class="headerlink" title="4. 节点"></a>4. 节点</h3><ul>
<li>What happens when a node dies?<ul>
<li>The tasks assigned to that machine will time-out and Nimbus will reassign those tasks to other machines.</li>
</ul>
</li>
</ul>
<h3 id="5-ack-fail确认机制"><a href="#5-ack-fail确认机制" class="headerlink" title="5. ack/fail确认机制"></a>5. ack/fail确认机制</h3><ul>
<li><strong><a href="http://storm.apache.org/releases/1.1.2/Guaranteeing-message-processing.html" target="_blank" rel="external">Guaranteeing Message Processing</a></strong></li>
</ul>
<p><strong>What happens if a message is fully processed or fails to be fully processed?</strong></p>
<pre><code>public interface ISpout extends Serializable {
    void open(Map conf, TopologyContext context, SpoutOutputCollector collector);
    void close();
    void nextTuple();
    void ack(Object msgId);
    void fail(Object msgId);
}
</code></pre><ul>
<li>First, Storm requests a tuple from the Spout by calling the nextTuple method on the Spout. The Spout uses the SpoutOutputCollector provided in the open method to emit a tuple to one of its output streams. When emitting a tuple, the Spout provides a “message id” that will be used to identify the tuple later.</li>
</ul>
<p><strong>What is Storm’s reliability API?</strong></p>
<pre><code>public class SplitSentence extends BaseRichBolt {
        OutputCollector _collector;

        public void prepare(Map conf, TopologyContext context, OutputCollector collector) {
            _collector = collector;
        }

        public void execute(Tuple tuple) {
            String sentence = tuple.getString(0);
            for(String word: sentence.split(&quot; &quot;)) {
                _collector.emit(tuple, new Values(word));
            }
            _collector.ack(tuple);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;word&quot;));
        }        
    }
</code></pre><ul>
<li>我们通过一个例子来看一下这个是怎么使用的</li>
</ul>
<pre><code>/**
 * Created by Thpffcj on 2018/4/4.
 * 使用Storm实现累计求和的操作
 */
public class LocalSumStormAckerTopology {

    /**
     * Spout需要继承BaseRichSpout
     * 数据源需要产生数据并发射
     */
    public static class DataSourceSpout extends BaseRichSpout {

        private SpoutOutputCollector collector;

        /**
         * 初始化方法，只会被调用一次
         *
         * @param conf      配置参数
         * @param context   上下文
         * @param collector 数据发射器
         */
        public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) {
            this.collector = collector;
        }

        int number = 0;

        /**
         * 会产生数据，在生产上肯定是从消息队列中获取数据
         * 这个方法是一个死循环，会一直不停的执行
         */
        public void nextTuple() {
            ++number;
            /**
             * emit方法有两个参数：
             *  1） 数据
             *  2） 数据的唯一编号 msgId
             *  如果是数据库，msgId就可以采用表中的主键
             */
            this.collector.emit(new Values(number), number);
            System.out.println(&quot;Spout: &quot; + number);

            // 防止数据产生太快
            Utils.sleep(1000);
        }

        @Override
        public void ack(Object msgId) {
            System.out.println(&quot; ack invoked ...&quot; + msgId);
        }

        @Override
        public void fail(Object msgId) {
            System.out.println(&quot; fail invoked ...&quot; + msgId);

            // TODO... 此处对失败的数据进行重发或者保存下来
            // this.collector.emit(tuple)
            // this.dao.saveMsg(msgId)
        }

        /**
         * 声明输出字段
         *
         * @param declarer
         */
        public void declareOutputFields(OutputFieldsDeclarer declarer) {
            declarer.declare(new Fields(&quot;num&quot;));
        }
    }

    /**
     * 数据的累积求和Bolt：接收数据并处理
     */
    public static class SumBolt extends BaseRichBolt {

        private OutputCollector collector;

        /**
         * 初始化方法，会被执行一次
         *
         * @param stormConf
         * @param context
         * @param collector
         */
        public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {
            this.collector = collector;
        }

        int sum = 0;

        /**
         * 其实也是一个死循环，职责：获取Spout发送过来的数据
         *
         * @param input
         */
        public void execute(Tuple input) {
            // Bolt中获取值可以根据index获取，也可以根据上一个环节中定义的field的名称获取(建议使用该方式)
            Integer value = input.getIntegerByField(&quot;num&quot;);
            sum += value;

            // 假设大于10的就是失败
            if (value &gt; 0 &amp;&amp; value &lt;= 10) {
                this.collector.ack(input); // 确认消息处理成功
            } else {
                this.collector.fail(input);  // 确认消息处理失败
            }

//            try {
//                // TODO... 你的业务逻辑
//                this.collector.ack(input);
//            } catch (Exception e) {
//                this.collector.fail(input);
//            }

            System.out.println(&quot;Bolt sum: &quot; + sum);
        }

        public void declareOutputFields(OutputFieldsDeclarer declarer) {

        }
    }

    public static void main(String[] args) {

        // TopologyBuilder根据Spout和Bolt来构建出Topology
        // Storm中任何一个作业都是通过Topology的方式进行提交的
        // Topology中需要指定Spout和Bolt的执行顺序
        TopologyBuilder builder = new TopologyBuilder();
        builder.setSpout(&quot;DataSourceSpout&quot;, new DataSourceSpout());
        builder.setBolt(&quot;SumBolt&quot;, new SumBolt()).shuffleGrouping(&quot;DataSourceSpout&quot;);


        // 创建一个本地Storm集群：本地模式运行，不需要搭建Storm集群
        LocalCluster cluster = new LocalCluster();
        cluster.submitTopology(&quot;LocalSumStormAckerTopology&quot;, new Config(),
                builder.createTopology());
    }
}
</code></pre><ul>
<li>效果就已经出现了</li>
</ul>
<pre><code>Spout: 1
29783 [Thread-20-__acker-executor[3 3]] INFO  o.a.s.d.executor - Prepared bolt __acker:(3)
Bolt sum: 1
 ack invoked ...1
Spout: 2
Bolt sum: 3
 ack invoked ...2
Spout: 3
Bolt sum: 6
 ack invoked ...3
Spout: 4
Bolt sum: 10
 ack invoked ...4
Spout: 5
Bolt sum: 15
 ack invoked ...5
Spout: 6
Bolt sum: 21
 ack invoked ...6
Spout: 7
Bolt sum: 28
 ack invoked ...7
Spout: 8
Bolt sum: 36
 ack invoked ...8
Spout: 9
Bolt sum: 45
 ack invoked ...9
Spout: 10
Bolt sum: 55
 ack invoked ...10
Spout: 11
Bolt sum: 66
 fail invoked ...11
Spout: 12
Bolt sum: 78
 fail invoked ...12
</code></pre>
            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2018/04/03/Linux-Programming/" style="float: left;">
        ← Linux程序设计
    </a>
    
    
    <a class="pull-right" href="/2018/03/31/Big-Data-Storm-Real-time-Streaming-Data-Processing-5/">
        并行度 →
    </a>
    
</nav>

        <div class="duoshuo">


</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
				<span id="busuanzi_container_site_pv">
					本站总访问量<span id="busuanzi_value_site_pv"></span>次
				</span>	
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Thpffcj.
                </p>
                <p>私は再び1日満たすためにあなたとの重要な人々を望みます</p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- ============================ END Footer =========================== -->

      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      (function(){
        console.log('font');
        var getCss = function(path) {
          var head = document.getElementsByTagName('head')[0];
          link = document.createElement('link');
          link.href = path;
          link.rel = 'stylesheet';
          link.type = 'text/css';
          head.appendChild(link);
        };
        getCss('https://fonts.googleapis.com/css?family=Montserrat:400,700');
        getCss('https://fonts.googleapis.com/css?family=Open+Sans:400,600');
      })();
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
